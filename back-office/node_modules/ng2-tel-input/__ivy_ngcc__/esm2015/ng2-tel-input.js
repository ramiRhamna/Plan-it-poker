import { EventEmitter, Directive, ElementRef, Inject, PLATFORM_ID, Input, Output, HostListener, NgModule } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * Generated from: src/ng2-tel-input.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
import * as ɵngcc0 from '@angular/core';
const defaultUtilScript = 'https://cdnjs.cloudflare.com/ajax/libs/intl-tel-input/16.0.1/js/utils.js';
class Ng2TelInput {
    /**
     * @param {?} el
     * @param {?} platformId
     */
    constructor(el, platformId) {
        this.el = el;
        this.platformId = platformId;
        this.ng2TelInputOptions = {};
        this.hasError = new EventEmitter();
        this.ng2TelOutput = new EventEmitter();
        this.countryChange = new EventEmitter();
        this.intlTelInputObject = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (isPlatformBrowser(this.platformId)) {
            this.ng2TelInputOptions = Object.assign({}, this.ng2TelInputOptions, { utilsScript: this.getUtilsScript(this.ng2TelInputOptions) });
            this.ngTelInput = window.intlTelInput(this.el.nativeElement, Object.assign({}, this.ng2TelInputOptions));
            this.el.nativeElement.addEventListener("countrychange", (/**
             * @return {?}
             */
            () => {
                this.countryChange.emit(this.ngTelInput.getSelectedCountryData());
            }));
            this.intlTelInputObject.emit(this.ngTelInput);
        }
    }
    /**
     * @return {?}
     */
    onBlur() {
        /** @type {?} */
        let isInputValid = this.isInputValid();
        if (isInputValid) {
            /** @type {?} */
            let telOutput = this.ngTelInput.getNumber();
            this.hasError.emit(isInputValid);
            this.ng2TelOutput.emit(telOutput);
        }
        else {
            this.hasError.emit(isInputValid);
        }
    }
    /**
     * @return {?}
     */
    isInputValid() {
        return this.ngTelInput.isValidNumber();
    }
    /**
     * @param {?} country
     * @return {?}
     */
    setCountry(country) {
        this.ngTelInput.setCountry(country);
    }
    /**
     * @param {?} options
     * @return {?}
     */
    getUtilsScript(options) {
        return options.utilsScript || defaultUtilScript;
    }
}
Ng2TelInput.ɵfac = function Ng2TelInput_Factory(t) { return new (t || Ng2TelInput)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID)); };
Ng2TelInput.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: Ng2TelInput, selectors: [["", "ng2TelInput", ""]], hostBindings: function Ng2TelInput_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("blur", function Ng2TelInput_blur_HostBindingHandler() { return ctx.onBlur(); });
    } }, inputs: { ng2TelInputOptions: "ng2TelInputOptions" }, outputs: { hasError: "hasError", ng2TelOutput: "ng2TelOutput", countryChange: "countryChange", intlTelInputObject: "intlTelInputObject" } });
/** @nocollapse */
Ng2TelInput.ctorParameters = () => [
    { type: ElementRef },
    { type: String, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
Ng2TelInput.propDecorators = {
    ng2TelInputOptions: [{ type: Input, args: ['ng2TelInputOptions',] }],
    hasError: [{ type: Output, args: ['hasError',] }],
    ng2TelOutput: [{ type: Output, args: ['ng2TelOutput',] }],
    countryChange: [{ type: Output, args: ['countryChange',] }],
    intlTelInputObject: [{ type: Output, args: ['intlTelInputObject',] }],
    onBlur: [{ type: HostListener, args: ['blur',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Ng2TelInput, [{
        type: Directive,
        args: [{
                selector: '[ng2TelInput]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: String, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }]; }, { ng2TelInputOptions: [{
            type: Input,
            args: ['ng2TelInputOptions']
        }], hasError: [{
            type: Output,
            args: ['hasError']
        }], ng2TelOutput: [{
            type: Output,
            args: ['ng2TelOutput']
        }], countryChange: [{
            type: Output,
            args: ['countryChange']
        }], intlTelInputObject: [{
            type: Output,
            args: ['intlTelInputObject']
        }], 
    /**
     * @return {?}
     */
    onBlur: [{
            type: HostListener,
            args: ['blur']
        }] }); })();

/**
 * @fileoverview added by tsickle
 * Generated from: src/ng2-tel-input.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Ng2TelInputModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: Ng2TelInputModule,
            providers: []
        };
    }
}
Ng2TelInputModule.ɵfac = function Ng2TelInputModule_Factory(t) { return new (t || Ng2TelInputModule)(); };
Ng2TelInputModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: Ng2TelInputModule });
Ng2TelInputModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Ng2TelInputModule, [{
        type: NgModule,
        args: [{
                declarations: [Ng2TelInput],
                exports: [Ng2TelInput]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(Ng2TelInputModule, { declarations: [Ng2TelInput], exports: [Ng2TelInput] }); })();

export { Ng2TelInput, Ng2TelInputModule };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmcyLXRlbC1pbnB1dC5qcyIsInNvdXJjZXMiOlsibmcyLXRlbC1pbnB1dC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs0TUFLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OEtBTUU7QUFDRjtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnRFbWl0dGVyLCBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdCwgUExBVEZPUk1fSUQsIElucHV0LCBPdXRwdXQsIEhvc3RMaXN0ZW5lciwgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEdlbmVyYXRlZCBmcm9tOiBzcmMvbmcyLXRlbC1pbnB1dC50c1xuICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGNvbnN0YW50UHJvcGVydHksZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKiogQHR5cGUgez99ICovXG5jb25zdCBkZWZhdWx0VXRpbFNjcmlwdCA9ICdodHRwczovL2NkbmpzLmNsb3VkZmxhcmUuY29tL2FqYXgvbGlicy9pbnRsLXRlbC1pbnB1dC8xNi4wLjEvanMvdXRpbHMuanMnO1xuY2xhc3MgTmcyVGVsSW5wdXQge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IHBsYXRmb3JtSWRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbCwgcGxhdGZvcm1JZCkge1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMucGxhdGZvcm1JZCA9IHBsYXRmb3JtSWQ7XG4gICAgICAgIHRoaXMubmcyVGVsSW5wdXRPcHRpb25zID0ge307XG4gICAgICAgIHRoaXMuaGFzRXJyb3IgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMubmcyVGVsT3V0cHV0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmNvdW50cnlDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuaW50bFRlbElucHV0T2JqZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBpZiAoaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSkge1xuICAgICAgICAgICAgdGhpcy5uZzJUZWxJbnB1dE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm5nMlRlbElucHV0T3B0aW9ucywgeyB1dGlsc1NjcmlwdDogdGhpcy5nZXRVdGlsc1NjcmlwdCh0aGlzLm5nMlRlbElucHV0T3B0aW9ucykgfSk7XG4gICAgICAgICAgICB0aGlzLm5nVGVsSW5wdXQgPSB3aW5kb3cuaW50bFRlbElucHV0KHRoaXMuZWwubmF0aXZlRWxlbWVudCwgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5uZzJUZWxJbnB1dE9wdGlvbnMpKTtcbiAgICAgICAgICAgIHRoaXMuZWwubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY291bnRyeWNoYW5nZVwiLCAoLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudHJ5Q2hhbmdlLmVtaXQodGhpcy5uZ1RlbElucHV0LmdldFNlbGVjdGVkQ291bnRyeURhdGEoKSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB0aGlzLmludGxUZWxJbnB1dE9iamVjdC5lbWl0KHRoaXMubmdUZWxJbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBvbkJsdXIoKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgbGV0IGlzSW5wdXRWYWxpZCA9IHRoaXMuaXNJbnB1dFZhbGlkKCk7XG4gICAgICAgIGlmIChpc0lucHV0VmFsaWQpIHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIGxldCB0ZWxPdXRwdXQgPSB0aGlzLm5nVGVsSW5wdXQuZ2V0TnVtYmVyKCk7XG4gICAgICAgICAgICB0aGlzLmhhc0Vycm9yLmVtaXQoaXNJbnB1dFZhbGlkKTtcbiAgICAgICAgICAgIHRoaXMubmcyVGVsT3V0cHV0LmVtaXQodGVsT3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGFzRXJyb3IuZW1pdChpc0lucHV0VmFsaWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgaXNJbnB1dFZhbGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZ1RlbElucHV0LmlzVmFsaWROdW1iZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb3VudHJ5XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBzZXRDb3VudHJ5KGNvdW50cnkpIHtcbiAgICAgICAgdGhpcy5uZ1RlbElucHV0LnNldENvdW50cnkoY291bnRyeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZ2V0VXRpbHNTY3JpcHQob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy51dGlsc1NjcmlwdCB8fCBkZWZhdWx0VXRpbFNjcmlwdDtcbiAgICB9XG59XG5OZzJUZWxJbnB1dC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW25nMlRlbElucHV0XScsXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbk5nMlRlbElucHV0LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogU3RyaW5nLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtQTEFURk9STV9JRCxdIH1dIH1cbl07XG5OZzJUZWxJbnB1dC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBuZzJUZWxJbnB1dE9wdGlvbnM6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ25nMlRlbElucHV0T3B0aW9ucycsXSB9XSxcbiAgICBoYXNFcnJvcjogW3sgdHlwZTogT3V0cHV0LCBhcmdzOiBbJ2hhc0Vycm9yJyxdIH1dLFxuICAgIG5nMlRlbE91dHB1dDogW3sgdHlwZTogT3V0cHV0LCBhcmdzOiBbJ25nMlRlbE91dHB1dCcsXSB9XSxcbiAgICBjb3VudHJ5Q2hhbmdlOiBbeyB0eXBlOiBPdXRwdXQsIGFyZ3M6IFsnY291bnRyeUNoYW5nZScsXSB9XSxcbiAgICBpbnRsVGVsSW5wdXRPYmplY3Q6IFt7IHR5cGU6IE91dHB1dCwgYXJnczogWydpbnRsVGVsSW5wdXRPYmplY3QnLF0gfV0sXG4gICAgb25CbHVyOiBbeyB0eXBlOiBIb3N0TGlzdGVuZXIsIGFyZ3M6IFsnYmx1cicsXSB9XVxufTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEdlbmVyYXRlZCBmcm9tOiBzcmMvbmcyLXRlbC1pbnB1dC5tb2R1bGUudHNcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxjb25zdGFudFByb3BlcnR5LGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAqL1xuY2xhc3MgTmcyVGVsSW5wdXRNb2R1bGUge1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgc3RhdGljIGZvclJvb3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTmcyVGVsSW5wdXRNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtdXG4gICAgICAgIH07XG4gICAgfVxufVxuTmcyVGVsSW5wdXRNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW05nMlRlbElucHV0XSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbTmcyVGVsSW5wdXRdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG5cbmV4cG9ydCB7IE5nMlRlbElucHV0LCBOZzJUZWxJbnB1dE1vZHVsZSB9O1xuIl19